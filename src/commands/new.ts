// TODO: Can we avoid disabling all of these rules?
/* eslint-disable @typescript-eslint/no-unsafe-member-access -- Prompts breaks this but its an external module so there's nothing we can do about it  */
/* eslint-disable @typescript-eslint/no-unsafe-assignment -- Prompts breaks this but its an external module so there's nothing we can do about it */

import { basename, dirname } from "path";
import { Command, flags } from "@oclif/command";
import kebabCase from "lodash.kebabcase";
import { constructApp } from "../utils/app";
import { checkPathDoesNotExist, checkPathExists } from "../utils/args";
import {
  newAppImports,
  newStackImports,
  newTestImports,
} from "../utils/imports";
import { buildDirectory } from "../utils/init";
import { cancellablePrompts } from "../utils/prompts";
import { constructTest } from "../utils/snapshot";
import type { StackTemplate } from "../utils/stack";
import { constructStack } from "../utils/stack";
import type { Name } from "../utils/utils";
import { pascalCase } from "../utils/utils";

interface NewCommandConfig {
  cdkDir: string;
  multiApp: boolean;
  appPath: string;
  appName: Name;
  stackPath: string;
  stackName: Name;
  testPath: string;
  init: boolean;
}

interface NewCommandArgs {
  output: string;
  app: string;
  stack: string;
}

interface NewCommandFlags {
  "multi-app": boolean;
  init: boolean;
}

export class NewCommand extends Command {
  static description = "Creates a new CDK stack";

  static flags = {
    version: flags.version({ char: "v" }),
    help: flags.help({ char: "h" }),
    "multi-app": flags.boolean({
      default: false,
      description:
        "create the stack files within sub directories as the project defines multiple apps",
    }),
    init: flags.boolean({
      default: false,
      description:
        "create the cdk directory before building the app and stack files",
    }),
  };

  static args = [
    {
      name: "output",
      required: true,
      description: "The CDK directory to create the new files in",
    },
    {
      name: "app",
      required: true,
      description: "A name to give the app",
    },
    {
      name: "stack",
      required: true,
      description: "A name to give the stack",
    },
  ];

  stackImports = newStackImports();

  template: StackTemplate = {
    Parameters: {},
  };
  static getConfig = ({
    args,
    flags,
  }: {
    args: NewCommandArgs;
    flags: NewCommandFlags;
  }): NewCommandConfig => {
    const cdkDir = args.output;
    const appName = pascalCase(args.app);
    const kebabAppName = kebabCase(appName);
    const stackName = pascalCase(args.stack);
    const kebabStackName = kebabCase(stackName);

    const config = {
      cdkDir,
      multiApp: flags["multi-app"],
      appName: {
        kebab: kebabAppName,
        pascal: appName,
      },
      appPath: `${cdkDir}/bin/${kebabAppName}.ts`,
      stackName: {
        kebab: kebabStackName,
        pascal: stackName,
      },
      stackPath: `${cdkDir}/lib/${
        flags["multi-app"] ? `${kebabAppName}/` : ""
      }${kebabAppName}.ts`,
      testPath: `${cdkDir}/lib/${
        flags["multi-app"] ? `${kebabAppName}/` : ""
      }${kebabAppName}.test.ts`,
      init: flags["init"],
    };

    NewCommand.validateConfig(config);

    return config;
  };

  static validateConfig = (config: NewCommandConfig): void => {
    if (!config.init) {
      checkPathExists(config.cdkDir);
    }
    checkPathDoesNotExist(config.appPath); // TODO: Update the app file if it already exists
    checkPathDoesNotExist(config.stackPath);
  };

  async run(): Promise<void> {
    this.log("Starting CDK generator");

    const config = NewCommand.getConfig(this.parse(NewCommand));

    if (config.init) {
      buildDirectory({ outputDir: config.cdkDir }, this);
    }

    this.log(
      `New app ${config.appName.pascal} will be written to ${config.appPath}`
    );
    this.log(
      `New stack ${config.stackName.pascal} will be written to ${config.stackPath}`
    );

    await this.getParameters();

    await constructApp({
      appName: config.appName,
      outputFile: "cdk.ts",
      outputDir: dirname(config.appPath),
      stack: config.stackName,
      imports: newAppImports(config.appName, config.multiApp),
      comment: `// This file was autogenerated when creating ${basename(
        config.stackPath
      )} using @guardian/cdk-cli\n// It is a starting point for migration to CDK *only*. Please check the output carefully before deploying`,
    });

    await constructStack({
      imports: this.stackImports,
      template: this.template,
      appName: config.appName,
      outputFile: basename(config.stackPath),
      outputDir: dirname(config.stackPath),
      comment: "// This file was autogenerated using @guardian/cdk-cli",
    });

    await constructTest({
      imports: newTestImports(config.appName),
      stackName: config.stackName,
      appName: config.appName,
      outputFile: basename(config.testPath),
      outputDir: dirname(config.stackPath),
      comment: "// This file was autogenerated using @guardian/cdk-cli",
    });
  }

  async getParameters(): Promise<void> {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition -- while true for the win, what could go wrong?
    while (true) {
      const nameResponse = await cancellablePrompts({
        type: "text",
        name: "parameterName",
        message: "Enter the name of the parameter (or hit enter to finish):",
      });

      if (!nameResponse.parameterName) break;

      const name = nameResponse.parameterName;

      // TODO: Can we be more clever here about the available types?
      const typeResponse = await cancellablePrompts({
        type: "text",
        name: "parameterType",
        message: "Enter the parameter type:",
        initial: "string",
      });

      const type = typeResponse.parameterType as string;

      if (type.toLowerCase() === "string") {
        this.template.Parameters[name] = {
          parameterType: "GuStringParameter",
        };

        this.stackImports.addImport("@guardian/cdk/lib/constructs/core", [
          "GuStringParameter",
        ]);
      } else {
        this.template.Parameters[name] = {
          parameterType: "GuParameter",
          type,
        };

        this.stackImports.addImport("@guardian/cdk/lib/constructs/core", [
          "GuParameter",
        ]);
      }
    }
  }
}
