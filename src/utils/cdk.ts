import { CfnParameterProps } from '@aws-cdk/core';
import { Config } from './args';
import { Imports } from './imports';
import { CodeMaker, toCamelCase } from 'codemaker';
import * as path from 'path';

interface CdkParameterProps extends CfnParameterProps {
  parameterType: string;
  comment?: string;
}

export interface CDKTemplate {
  Parameters: {
    [key: string]: CdkParameterProps;
  };
}

export class CdkBuilder {
  config: Config;
  imports: Imports;
  template: CDKTemplate;

  code: CodeMaker;

  constructor(config: Config, imports: Imports, template: CDKTemplate) {
    this.config = config;
    this.imports = imports;
    this.template = template;

    this.code = new CodeMaker({ indentationLevel: 2 });
    this.code.closeBlockFormatter = (s?: string): string => s ?? '}';
  }

  async constructCdkFile(): Promise<void> {
    this.code.openFile(this.config.outputFile);
    this.code.line(
      `// This file was autogenerated from ${path.basename(
        this.config.cfnPath
      )} by @guardian/generate-cdk`
    );
    this.code.line(
      `// It is a starting point for migration to CDK *only*. Please check the output carefully before deploying`
    );

    this.addImports();

    this.code.openBlock(
      `export class ${this.config.stackName} extends GuStack`
    );
    this.code.openBlock(
      `constructor(scope: Construct, id: string, props?: StackProps)`
    );
    this.code.line('super(scope, id, props);');

    this.addParams();

    this.code.closeBlock();
    this.code.closeBlock();

    this.code.closeFile(this.config.outputFile);
    await this.code.save(this.config.outputDir);
  }

  // TODO: Update this for our preferred style of imports
  addImports(): void {
    this.code.line();
    Object.keys(this.imports.imports)
      .sort()
      .forEach((lib) => {
        const components = this.imports.imports[lib];

        this.code.line(
          `import { ${components?.sort().join(', ')} } from "${lib}";`
        );
      });
    this.code.line();
  }

  addParams(): void {
    this.code.line();
    this.code.line('/* Parameters */');

    this.code.line(
      '// TODO: Consider if any of the helper classes in components/core/parameters.ts file could be used here'
    );
    this.code.openBlock(`const parameters =`);

    Object.keys(this.template.Parameters).forEach((paramName) => {
      this.addParam(paramName, this.template.Parameters[paramName]);
    });

    this.code.closeBlock('};');
  }

  addParam(name: string, props: CdkParameterProps): void {
    if (props.comment) {
      this.code.line(`// ${props.comment}`);
    }

    this.code.indent(`${name}: new ${props.parameterType}(this, "${name}", {`);

    Object.entries(props).forEach((val) => {
      const pKey = toCamelCase(val[0]);

      if (!this.shouldSkipParamProp(pKey, val[1])) {
        this.code.line(`${pKey}: ${this.formatParam(pKey, val[1])},`);
      }
    });

    this.code.unindent(`}),`);
  }

  formatParam(name: string, value: any): any {
    switch (name) {
      case 'noEcho':
        return value;
      case 'allowedValues':
        return `[${value.map((v: string) => `"${v}"`)}]`;
      default:
        return `"${value}"`;
    }
  }

  shouldSkipParamProp(key: string, val: any): boolean {
    const keysToSkip = ['parameterType', 'comment'];

    if (keysToSkip.includes(key)) return true;

    // Special cases

    if (key === 'type' && val === 'String') return true;

    return false;
  }
}

export const construct = (
  config: Config,
  imports: Imports,
  template: CDKTemplate
): void => {
  const builder = new CdkBuilder(config, imports, template);
  builder.constructCdkFile();
};
