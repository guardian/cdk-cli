import { CfnParameterProps } from '@aws-cdk/core';
import { Config } from './args';
import { Imports } from './imports';
import { CodeMaker, toCamelCase } from 'codemaker';
import * as path from 'path';

interface CdkParameterProps extends CfnParameterProps {
  parameterType: string;
  comment?: string;
}

export interface CDKTemplate {
  Parameters: {
    [key: string]: CdkParameterProps;
  };
}

class CdkBuilder {
  config: Config;
  imports: Imports;
  template: CDKTemplate;

  code: CodeMaker;

  paramFormatters: { [key: string]: (val: any) => any } = {
    default: (val: string) => `"${val}"`,
    noEcho: (val) => val,
    allowedValues: (val) => `[${val.map((v: string) => `"${v}"`)}]`,
  };

  constructor(config: Config, imports: Imports, template: CDKTemplate) {
    this.config = config;
    this.imports = imports;
    this.template = template;

    this.code = new CodeMaker();
  }

  async constructCdkFile(): Promise<void> {
    this.code.openFile(this.config.output_file);
    this.code.line(
      `// This file was autogenerated from ${path.basename(
        this.config.cfn_path
      )} by @guardian/generate-cdk`
    );
    this.code.line(
      `// It is a starting point for migration to CDK *only*. Please check the output carefully before deploying`
    );

    this.addImports();

    this.code.openBlock(
      `export class ${this.config.stack_name} extends cdk.Stack`
    );
    this.code.openBlock(
      `constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps)`
    );
    this.code.line('super(scope, id, props)');

    this.addParams();

    this.code.closeBlock();
    this.code.closeBlock();

    this.code.closeFile(this.config.output_file);
    await this.code.save(this.config.output_dir);
  }

  addImports(): void {
    this.code.line();
    this.code.line(`import cdk = require("@aws-cdk/core")`);
    Object.keys(this.imports.imports).forEach((lib) => {
      const libProps = this.imports.imports[lib];
      switch (libProps.type) {
        case 'all':
          this.code.line(`import * as ${libProps.name} from "${lib}"`);
          break;
        case 'require':
          this.code.line(`import ${libProps.name} = require("${lib}")`);
          break;
        case 'component':
          this.code.line(
            `import {${libProps.components?.join(', ')}} from "${lib}"`
          );
          break;
      }
    });
    this.code.line();
  }

  addParams(): void {
    this.code.line();
    this.code.line('/* Parameters */');

    this.code.line(
      '// TODO: Consider if any of the helper classes in components/core/parameters.ts file could be used here'
    );
    this.code.openBlock(`const parameters =`);
    Object.keys(this.template.Parameters).forEach((paramName) => {
      const param = this.template.Parameters[paramName];
      if (param.comment) {
        this.code.line(`// ${param.comment}`);
      }
      this.code.indent(
        `${paramName}: new ${param.parameterType}(this, "${paramName}", {`
      );
      Object.entries(param).forEach((val) => {
        const pKey = toCamelCase(val[0]);

        let skip = false;

        if (
          pKey === 'parameterType' ||
          pKey === 'comment' ||
          (pKey === 'type' && val[1] === 'String')
        ) {
          skip = true;
        }

        if (!skip) {
          const pValue = this.paramFormatters[pKey]
            ? this.paramFormatters[pKey](val[1])
            : this.paramFormatters.default(val[1]);
          this.code.line(`${pKey}: ${pValue},`);
        }
      });
      this.code.unindent(`}),`);
    });
    this.code.closeBlock();
  }
}

export const construct = (
  config: Config,
  imports: Imports,
  template: CDKTemplate
): void => {
  const builder = new CdkBuilder(config, imports, template);
  builder.constructCdkFile();
};
